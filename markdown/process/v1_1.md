# AI Debug Copilot - Backend V1.2 持久化任务（给 Codex）

你是 Codex，请为现有后端（FastAPI + 本地 Ollama qwen2.5:7b-instruct）增加 **PostgreSQL + Prisma** 数据持久化能力，并尽量保持现有 API 返回格式不变。

## 重要背景（请务必遵守）
- 我（提问者）对后端不熟，所以：
  1) 生成的代码请尽量 **多写注释**（为什么这么做、关键字段含义、调用关系）
  2) 每个新文件顶部写简短注释说明用途
  3) 复杂逻辑请拆函数并加 docstring
- 前端 UI 已完成，不需要改 UI。当前已稳定调用 `POST /debug` 并渲染返回结果。
- 现有后端接口（稳定基线）：
  - `POST /debug`
  - Request:
    ```json
    { "language": "ts", "errorText": "...", "codeSnippet": "..." }
    ```
  - Response（必须保持兼容）：
    ```json
    {
      "error_type": "TypeError",
      "root_cause": ["..."],
      "fix_suggestions": ["..."],
      "prevention": ["..."],
      "raw_model_output": "..."
    }
    ```

## 目标
1) 引入 PostgreSQL 持久化三类数据：
   - DebugSession（会话）
   - Message（用户/助手消息）
   - DebugResult（一次结构化分析结果）
2) 在不破坏现有 `POST /debug` 的前提下：
   - 每次 /debug 调用都能落库：user message、assistant message、debug result
   - 支持传入可选 `session_id`，用于把多次 /debug 归到同一个会话（为后续多轮做准备）
3) 新增两个读取接口（用于后续历史记录功能）：
   - `GET /sessions`：返回最近 N 个 session（id、createdAt、lastMessageAt、messageCount）
   - `GET /sessions/{session_id}`：返回该 session 的 messages（按时间排序），以及每条 assistant message 对应的 debug result（如果有）

## 数据模型设计要求（Prisma）
请按以下关系建模（你可微调字段名，但要解释原因）：

### DebugSession
- id: string(uuid)
- userId: string | null（先支持匿名，后续接 Auth 再填）
- createdAt, updatedAt
- messages: Message[]

### Message
- id: string(uuid)
- sessionId: DebugSession.id
- role: "user" | "assistant"
- language: string | null（user message 才有）
- errorText: string | null（user message 才有）
- codeSnippet: string | null（user message 才有）
- assistantJson: Json | null（assistant message 才有：结构化结果）
- rawModelOutput: string | null（assistant message 才有）
- createdAt

### DebugResult（可选：如果你认为 assistant message 里存 Json 就够了，也可以不单独建表，但要说明 trade-off）
如果单独建表：
- id: string(uuid)
- messageId: Message.id（对应 assistant message）
- errorType: string
- rootCause: Json（array）
- fixSuggestions: Json（array）
- prevention: Json（array）
- rawModelOutput: string
- modelName: string（例如 "qwen2.5:7b-instruct"）
- promptVersion: string（例如 "v1"）
- createdAt

**请解释：为什么某些字段用 Json/JsonB，为什么某些字段需要索引。**

## FastAPI 实现要求


- 一次 `/debug` 调用中，以下数据库写操作必须作为一个事务完成：
  1) 创建（或复用） DebugSession
  2) 创建 user Message
  3) 创建 assistant Message
  4) （如果有）创建 DebugResult

- 事务语义：
  - 上述 1~4 任一步失败，数据库中不应留下任何“半成品”数据
  - 例如：不能出现只有 user message、但没有 assistant message 的情况

- 实现约束：
  - 事务边界应放在 `debug_service` 层，而不是 FastAPI 路由层
  - 路由层（main.py）不应直接开启或管理事务



- 使用环境变量读取 DB 连接串（DATABASE_URL）
- 需要提供：
  - prisma schema
  - migration 指令说明（README 或注释）
  - FastAPI 中一个清晰的 db client 初始化方式
- `POST /debug` 行为：
  1) 若请求体有 session_id：使用该 session；否则创建新 session，并返回时在 response header 或 response body 里带回 session_id（二选一，解释原因）
  2) 创建 user message（role=user，保存 language/errorText/codeSnippet）
  3) 调用现有 Ollama 推理逻辑得到结构化结果 + raw_model_output
  4) 创建 assistant message（role=assistant，保存 assistantJson + rawModelOutput）
  5) （如果有 DebugResult 表）写入 DebugResult
  6) 返回值保持现有 response 格式稳定

## 工程与可读性要求（我后端不熟）
- 代码结构建议：
  - app/main.py（路由入口）
  - app/db.py（DB client）
  - app/models.py 或 app/schemas.py（Pydantic 请求响应）
  - app/services/debug_service.py（调用模型 + 落库编排）
- 每个函数写清楚输入输出
- 对关键决策写注释：比如为什么把 session_id 放 header/body，为什么 Json 存在 message 或 result

## 输出内容（Codex 必须给出）
1) 需要新增/修改的文件列表
2) 每个文件的完整代码
3) 如何本地启动（包括 Postgres、环境变量、迁移、启动 FastAPI）
4) 用 curl 演示：
   - 创建新 session 的 /debug
   - 带 session_id 的 /debug
   - 查询 sessions 列表
   - 查询某个 session 详情

## 可读性与注释的强制验收标准

以下条件 **必须满足**，否则输出不合格：

1) 每个 public 函数必须有 docstring，至少包含：
   - 这个函数做什么
   - 输入参数含义
   - 返回值含义
   - 可能抛出的异常（如果有）

2) 每个事务边界（begin / transaction / commit / rollback）附近，
   必须有注释解释：
   - 为什么在这里开启事务
   - 事务包含哪些操作
   - 失败时会发生什么

3) 每个文件顶部必须有注释，说明：
   - 该文件的职责
   - 它和其他文件的关系

4) 如果你发现自己没有写足够注释，请在输出前自行补齐

## 输出节奏要求

请分阶段输出，而不是一次性生成全部代码：

- 第一步：只给出数据模型（Prisma schema）+ 设计说明
- 第二步：只给出 db.py（DB client + transaction 管理）
- 第三步：只给出 debug_service.py（业务编排 + 事务）
- 第四步：只给出 main.py（路由层）

每一步都需要：
- 完整代码
- 设计说明
- 为什么这样分层